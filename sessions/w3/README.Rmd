---
title: "Week 3 - Data Structures in R"
author: "Naveen Venkataraman"
date: "October 17, 2015"
output: html_document
---

## Data Types in R

R's data types can be organized based on:

1. Dimensionality
2. Homogenous (all contents are same)
3. Heterogenous (contents can be different)

|Dimension|Homogenous |Heterogenous|
|----------:|----------:|----------:|
|1d| **Atomic Vector**|List|
|2d| **Matrix**| **Data Frame**|
|nd| Array||

---

### Some key points

In R,

1. No static typing, means
    + No upfront variable type declarations necessary
    + Variable type can change without explicit recasting
2. Variable names can contain any combination of alphanumeric characters along with periods (.) and underscores (_). However, they cannot start with a number or an underscore
3. Index values start from 1. This means, there's no 0-th element.

---

## Atomic Vector (henceforth refered to as ```vector```)

Simplest data type in R. Variable types are called ```modes```.

Note: R does not have a ```scalar``` data type. Scalars in R are vectors of length = 1.

Modes include:

1. logical
2. character
3. double / numeric  (with decimals)
4. integer (whole numbers, no decimals)

##### Properties of vectors

+ Type, typeof(), what it is.
+ Length, length(), how many elements it contains.
+ Attributes, attributes(), additional arbitrary metadata.

##### 2. Vector creation

Create a vector using ```c()```

```{r}
log_vec <- c(TRUE,FALSE,TRUE,T,F) ## logical
typeof(log_vec)
length(log_vec)
attributes(log_vec)

char_vec <- c("hello","world!") ## character
    
num_vec <- c(1L,3L,5L) ## integer

dbl_vec <- c(1.5, 3.1416) ## double

```

##### Adding Vector elements

```{r}
num_vec[4] <- 7L ## You can only do this if you know the dimensions and if you know the last used index
num_vec

num_vec <- c(num_vec,9)
num_vec
```

##### Indexing a vector

+ vector[index]

Note:

+ Square brackets ```[]```
+ Index: numerical, combination or named position

```{r}
name_vec <- c("patriots", "packers", "broncos", "49ers")

name_vec[0] ## null vector

name_vec[1]

name_vec[5] ## NA

name_vec[c(1,3)] ## including specific positions

name_vec[-1] ## excluding a vector position

name_vec[-c(2,4)] ## excluding specific positions

## named positions
names(name_vec) <- c("new england", "green bay", "denver", "sf")

name_vec["green bay"]


```

##### Types and tests

+ typeof()
+ _is.type()_, where type = character, logical, integer, double

##### Type Coercion

```{r}

num_vec <- c(1L,3L,5L) ## create the vector

is.integer(num_vec)

is.double(num_vec)

num_vec <- c(num_vec, 6.5) ## add a new element

is.integer(num_vec)

is.double(num_vec)

```

##### Useful functions

+ is.na
+ complete.cases
+ rep
+ seq
+ seq_along

##### Operations

Arithmetic

+ Addition
+ Subtraction
+ Multiplication
+ Division
+ Modulo

---

## Matrices

##### Properties

+ Dimensionality, dim(), number of rows and columns

##### Creating a matrix

```{r}
mat1 <- matrix(1:12)
mat1
attributes(mat1) ## note attributes
dim(mat1)

mat2 <- matrix(1:12, nrow = 4)
mat2

dim(mat2)

mat3 <- matrix(1:12, ncol = 4)
mat3

mat4 <- matrix(1:12, ncol = 4, byrow = TRUE)
mat4

mat5 <- matrix(1:12, ncol = 4, nrow = 5)
mat5

```

##### Indexing a matrix

**mat_variable[row, column]**

```{r}

mat4
mat4[2,1]

attributes(mat4[2,1]) ## Q: Why is this NULL?

mat4[2,]

mat4[,1]

mat4[,-1]

```

##### Adding / Removing Matrix Rows and Columns

Technically, matrices are of fixed length and dimensions, so we cannot add or delete rows or columns. However, matrices can be reassigned, and thus we can achieve the same effect as if we had directly done additions or deletions.

This is done using ```rbind()``` **(to append rows)** and ```cbind()``` **to append columns**.

```{r}
mat1 <- matrix(1:20, nrow=5)
mat1

rbind(mat1, c(40:43))

mat1 <- rbind(mat1, c(40:43))
mat1

mat2 <- matrix(1:9, nrow=3, byrow = TRUE)
mat2

cbind(mat2, matrix(100:102, ncol=1))

mat2 <- cbind(mat2, matrix(100:102, ncol=1))
mat2

```

##### Matrix operations (matrix multiplication)

__Use %*% operator__

```{r}
mat1 <- matrix(1:4,nrow = 2)
mat1

mat2 <- matrix(100:103, nrow = 2)
mat2

mat1 %*% mat2
```

---

## Data Frames

##### Creating a dataframe

+ ```data.frame()```
+ **named vectors**


```{r}
df_league <- data.frame(city=c("green bay", "new england", "seattle", "chicago"), 
                        teams=c("packers", "pats", "seahawks", "bears"))
df_league

attributes(df_league)
```

##### Properties

+ ```names()``` / ```colnames()```
+ ```rownames()```
+ ```length()```
+ ```nrow()```
+ ```ncol()```

```{r}
length(df_league)
ncol(df_league)

length(df_league[,1])

nrow(df_league)

names(df_league)

rownames(df_league)
```

##### Combining data frames

```{r}
df_league

df_league <- data.frame(df_league, exp_standing=c(5:8))

names(df_league)
```

##### Indexing a data frame

**dataframe_variable[row,col]**

```{r}
df_league

df_league[,1]

df_league[1,]

df_league[-1,]

df_league[,-1]
```


---

## Problem Sets

1. Generate 1000 normally distributed random numbers and store it in vector _v1_
+ Select the first 100 numbers and plot them
+ Plot the top 20th percentile (may not work since they don't know filtering)